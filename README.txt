Marc Beitchman
mbeitchman@gmail.com

My servers are designed such that all common code that is shared between both servers is defined in common.h and common.c. The following classes are defined in common.h: HTTPResponseHelper, HTTPRequestParser, and HTTPRequestBuffer. The HTTPResponseHelper initializes responses for each of the resources on object contstruction and then provides functions to provide the responses. The HTTPRequestBuffer is used to hold requests between getting data from the socket and validate http requests. The HTTPRequestParser parses the request and returns the requested resource.  

Socket handling is done directly in each server using the socket functions defined in socket.h. I designed a SocketNode class and a SocketNodeList class in socketlist.h and socketlist.c which are only used by the event driven server. The SocketNode class stores all of the information about the state of a socket including file descriptor, response buffer and current position in the response buffer and the actual state (reading, writing, closed) of the socket. The event driven server interacts with SocketNode's through the SocektNodeList class which contains a linked list of sockets and provides methods for the server to manipulate and get data from the list.

My threaded server is implemented in t-server.c. The file contains the main function for the server along with the thread function and the ctrl-c handler that I register to handle SIGINT. The ctrl-c handler is reponsible for clean-up for the module. Other than checking the input arguments, I raise ctrl-c when I initialize the server instead of directly returning  so I can ensure cleanly clean-up. The main thread of this server sets-up the initial streaming socket and then enters a loop which calls accept and when accept returns creates a new thread which takes the new file descriptor of the new socket as an argument. The thread is detatched from the main loop and then the main loop is repeated. The thread function receives the response and prepares and sends the response and then exits. The http helper objects are created on the stack for each thread function.

My event driven server is implemented in ed-server.c. The file contains the main function for the server along with a ctrl-c handler for clean-up as well as three helper functions. The helper functions are named HandleSockets, SetNonBlocking and BuildSocketList. The execution sequence is that first new instances of the socket list and the http helpers are created, next the main listening socket is set-up and set to non-blocking using the SetNonBlocking helper function, next the server enters a loop where it builds (via the BuildSocketList helper function) the list of readable and writable sockets to pass to select by looping through all of the socket nodes and checking their state, select is called and waits for 500 milliseconds and if any sockets are ready the HandleSockets helper function is called. Othwerwise, the loop is repeated. The HandleSockets helper checks every socket in the list to see if they are in the read set or the write set and either opens a socket, sends data on a socket, receives data on a socket or closes the socket as appropriate. The HandleSockets helper also updates the state of the socket node as appropriate.

No third party code was used in my implementation.

Testing was performed on Safari, Firefox and Chrome. Both servers performed well under stressful conditions such as rapid requests (holding ctrl-r) from multiple machines. I ran the severs under Valgrind under the stressful scenarios with fd tracking on. No memory leaks and no sockets were leaked for either server in all scenarios. Valgrind reported three open file descriptors inherited from the parent open at the end of execution. I verified they are stdin, stdout and stderror by calling fclose on stdin, stdout aand stderr and the open file descriptors went away.

For the threaded server, I ran httperf at a rate of 100 requests per second for 100 requests for a2.html. The server handled this load at 51.2 requests/second between my home network and attu.

For the event driven server, I ran httperf at a rate of 100 requests per second for 100 requests for a2.html. The server handled this load at 54.6 requests/second between my home network and attu.

I discussed the project with Brad Burkett. We did not share any code but discussed the project and helped each other solve issues. This project was very interesting and fun.